<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Semantic Compression Demo v0.1.0</title>
  <style>
    :root {
      --bg-top: #101826;
      --bg-bottom: #070b12;
      --panel: #121a2a;
      --panel-border: #26354f;
      --chip: #0d1421;
      --ink: #e4ecff;
      --muted: #a2b5d7;
      --accent-a: #63b7ff;
      --accent-b: #ffcb76;
      --accent-c: #7de0b8;
      --danger: #f79b9b;
      --mono: "Cascadia Mono", "Consolas", "Menlo", monospace;
      --sans: "Segoe UI", "Trebuchet MS", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--ink);
      background:
        radial-gradient(1200px 500px at 10% 0%, rgba(99, 183, 255, 0.17), transparent 60%),
        radial-gradient(800px 500px at 100% 100%, rgba(255, 203, 118, 0.12), transparent 60%),
        linear-gradient(165deg, var(--bg-top), var(--bg-bottom));
      min-height: 100vh;
    }

    .shell {
      width: min(1200px, 96vw);
      margin: 20px auto;
      display: grid;
      gap: 12px;
    }

    .panel {
      background: linear-gradient(180deg, rgba(18, 26, 42, 0.93), rgba(14, 21, 33, 0.93));
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      box-shadow: 0 14px 36px rgba(0, 0, 0, 0.36);
      padding: 12px 14px;
    }

    .header { display: grid; gap: 6px; }

    h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.3px;
    }

    .tag {
      display: inline-block;
      margin-left: 8px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #3f5f8f;
      background: rgba(28, 48, 76, 0.68);
      color: #d3e7ff;
      font-family: var(--mono);
      font-size: 12px;
    }

    .subtitle {
      margin: 0;
      color: var(--muted);
      line-height: 1.35;
      font-size: 14px;
    }

    .controls { display: grid; gap: 10px; }

    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button {
      border: 1px solid #34507a;
      background: #17345a;
      color: #ebf3ff;
      border-radius: 10px;
      padding: 10px 12px;
      font-family: var(--sans);
      font-weight: 600;
      cursor: pointer;
    }

    button:active { transform: translateY(1px); }

    button.alt {
      border-color: #6f5b37;
      background: #4a3720;
      color: #ffedcf;
    }

    button.soft {
      border-color: #395175;
      background: #1a283f;
      color: #d0def6;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      background: var(--chip);
      border: 1px solid #27364f;
      border-radius: 999px;
      padding: 5px 10px;
      font-family: var(--mono);
      font-size: 12px;
      color: #d5e4ff;
    }

    /* Slightly clearer OK/BROKEN chips */
    .chip.ok { color: var(--accent-c); border-color: rgba(125, 224, 184, 0.55); }
    .chip.warn { color: var(--danger); border-color: rgba(247, 155, 155, 0.55); }

    .legend {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }

    .kbd {
      display: inline-block;
      min-width: 16px;
      text-align: center;
      border: 1px solid #334968;
      border-radius: 6px;
      background: #0a111d;
      padding: 1px 6px;
      color: #d9e8ff;
      font-family: var(--mono);
      font-size: 12px;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.35fr 1fr;
      gap: 12px;
    }

    canvas {
      width: 100%;
      height: 560px;
      display: block;
      border-radius: 14px;
      border: 1px solid #24344f;
      background:
        radial-gradient(700px 300px at 50% 35%, rgba(85, 127, 191, 0.18), transparent 64%),
        linear-gradient(170deg, #0d1422, #09101a);
    }

    .side {
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 12px;
      min-height: 560px;
    }

    .card-title {
      margin: 0 0 8px 0;
      font-size: 14px;
      letter-spacing: 0.2px;
      color: #c4d8fb;
    }

    .json {
      margin: 0;
      max-height: 220px;
      overflow: auto;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #263650;
      background: #0b121f;
      color: #d8e6ff;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
    }

    .log {
      margin: 0;
      padding: 0 0 0 20px;
      max-height: 280px;
      overflow: auto;
      color: #c9ddff;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
    }

    .log li { margin-bottom: 8px; }

    @media (max-width: 980px) {
      .layout { grid-template-columns: 1fr; }
      .side { min-height: 0; }
    }
  </style>
</head>
<body>
  <div class="shell">
    <section class="panel header">
      <h1>Semantic Compression: Relax / Constrain Demo <span class="tag">v0.1.0</span></h1>
      <p class="subtitle">
        Visual metaphor: a point cloud explores under RELAX and forms structure under CONSTRAIN.
        Frame shift operator "FRAME SHIFT (X↔Y)" swaps the target manifold.
      </p>
    </section>

    <section class="panel controls">
      <div class="buttons">
        <button id="relaxBtn">RELAX</button>
        <button id="constrainBtn">CONSTRAIN</button>
        <button id="switchBtn" class="alt">FRAME SHIFT (X↔Y)</button>
        <button id="resetBtn" class="soft">Reset</button>
      </div>
      <div class="chips">
        <span class="chip" id="modeChip">Mode: IDLE</span>
        <span class="chip" id="frameChip">Frame: X / Y (active X)</span>
        <span class="chip" id="spreadChip">Spread: 0.0000</span>
        <span class="chip" id="errorChip">Constraint error: 0.0000</span>
        <span class="chip" id="hashChip">Last commit hash: 00000000</span>
        <span class="chip ok" id="chainChip">Chain: OK</span>
      </div>
      <div class="legend">
        Hotkeys:
        <span class="kbd">R</span> RELAX,
        <span class="kbd">C</span> CONSTRAIN,
        <span class="kbd">X</span> switch frame,
        <span class="kbd">Space</span> idle,
        <span class="kbd">Enter</span> reset.
      </div>
    </section>

    <section class="layout">
      <canvas id="viz"></canvas>
      <div class="side">
        <article class="panel">
          <h2 class="card-title">Last Commit</h2>
          <pre class="json" id="lastCommit"></pre>
        </article>
        <article class="panel">
          <h2 class="card-title">Lineage Log (Merkle-like)</h2>
          <ol class="log" id="lineageLog"></ol>
        </article>
      </div>
    </section>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("viz");
      const ctx = canvas.getContext("2d");

      const modeChip = document.getElementById("modeChip");
      const frameChip = document.getElementById("frameChip");
      const spreadChip = document.getElementById("spreadChip");
      const errorChip = document.getElementById("errorChip");
      const hashChip = document.getElementById("hashChip");
      const chainChip = document.getElementById("chainChip");
      const lastCommitEl = document.getElementById("lastCommit");
      const lineageLogEl = document.getElementById("lineageLog");

      const N = 420;
      const points = [];
      const commits = [];

      let mode = "IDLE";
      let frame = "X";
      let nextCommit = 0;
      let cachedMetrics = { spread: 0, constraintError: 0 };

      // Cache canvas size in CSS pixels after resize()
      let viewW = 0;
      let viewH = 0;

      // Cache mono font string once (trim leading spaces from CSS var)
      const monoFont = getComputedStyle(document.documentElement)
        .getPropertyValue("--mono")
        .trim() || "monospace";

      const params = {
        relaxNoise: 0.02,
        relaxDrift: 0.0025,
        constrainStrength: 0.1,
        friction: 0.985,
        velDamp: 0.7
      };

      function randRange(min, max) { return min + Math.random() * (max - min); }
      function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

      function gauss() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
      }

      function pad4(n) { return String(n).padStart(4, "0"); }

      function stableString(value) {
        if (value === null || typeof value !== "object") return JSON.stringify(value);
        if (Array.isArray(value)) return "[" + value.map(stableString).join(",") + "]";
        const keys = Object.keys(value).sort();
        return "{" + keys.map(k => JSON.stringify(k) + ":" + stableString(value[k])).join(",") + "}";
      }

      function toyHash(str) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return ("0000000" + (h >>> 0).toString(16)).slice(-8);
      }

      function resize() {
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        canvas.width = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        viewW = rect.width;
        viewH = rect.height;
      }
      window.addEventListener("resize", resize);

      function targetX(t) {
        const r = 0.62;
        return { x: r * Math.cos(t), y: r * Math.sin(t) };
      }

      function targetY(t) {
        const a = 0.7;
        const denom = 1 + Math.sin(t) * Math.sin(t);
        return {
          x: (a * Math.cos(t)) / denom,
          y: (a * Math.sin(t) * Math.cos(t)) / denom
        };
      }

      function target(t) { return frame === "X" ? targetX(t) : targetY(t); }

      function nearestOnManifold(px, py) {
        let best = { x: 0, y: 0, t: 0, d2: Infinity };

        const coarse = 96;
        for (let i = 0; i < coarse; i++) {
          const t = (i / coarse) * Math.PI * 2;
          const q = target(t);
          const dx = px - q.x;
          const dy = py - q.y;
          const d2 = dx * dx + dy * dy;
          if (d2 < best.d2) best = { x: q.x, y: q.y, t, d2 };
        }

        const refine = 32;
        const span = (Math.PI * 2) / coarse;
        for (let i = 0; i < refine; i++) {
          const a = i / (refine - 1);
          const t = best.t + (a * 2 - 1) * span;
          const q = target(t);
          const dx = px - q.x;
          const dy = py - q.y;
          const d2 = dx * dx + dy * dy;
          if (d2 < best.d2) best = { x: q.x, y: q.y, t, d2 };
        }
        return best;
      }

      function createPoint() {
        return {
          x: randRange(-0.14, 0.14),
          y: randRange(-0.14, 0.14),
          vx: gauss() * 0.01,
          vy: gauss() * 0.01
        };
      }

      function resetPoints() {
        points.length = 0;
        for (let i = 0; i < N; i++) points.push(createPoint());
      }

      function bounce(p) {
        const bound = 1.08;
        if (p.x < -bound || p.x > bound) { p.vx *= -0.72; p.x = clamp(p.x, -bound, bound); }
        if (p.y < -bound || p.y > bound) { p.vy *= -0.72; p.y = clamp(p.y, -bound, bound); }
      }

      function integrateRelax() {
        for (const p of points) {
          p.vx = p.vx * params.friction + gauss() * params.relaxNoise + p.x * params.relaxDrift;
          p.vy = p.vy * params.friction + gauss() * params.relaxNoise + p.y * params.relaxDrift;
          p.x += p.vx; p.y += p.vy;
          bounce(p);
        }
      }

      function integrateConstrain(strength) {
        const k = strength === undefined ? params.constrainStrength : strength;
        for (const p of points) {
          const near = nearestOnManifold(p.x, p.y);
          const dx = near.x - p.x;
          const dy = near.y - p.y;
          p.vx = p.vx * params.velDamp + dx * k;
          p.vy = p.vy * params.velDamp + dy * k;
          p.x += p.vx; p.y += p.vy;
          bounce(p);
        }
      }

      function coast() {
        for (const p of points) {
          p.vx *= 0.994;
          p.vy *= 0.994;
          p.x += p.vx;
          p.y += p.vy;
          bounce(p);
        }
      }

      function round4(x) { return Number(x.toFixed(4)); }

      function measure() {
        let mx = 0, my = 0;
        for (const p of points) { mx += p.x; my += p.y; }
        mx /= points.length; my /= points.length;

        let variance = 0;
        let err = 0;
        for (const p of points) {
          const dx = p.x - mx;
          const dy = p.y - my;
          variance += dx * dx + dy * dy;
          err += Math.sqrt(nearestOnManifold(p.x, p.y).d2);
        }
        variance /= points.length;
        err /= points.length;

        return { spread: round4(variance), constraintError: round4(err) };
      }

      function addCommit(nextMode, payloadFrame, payloadParams, payloadMetrics) {
        const parent = commits.length ? commits[commits.length - 1] : null;
        const id = pad4(nextCommit);
        const parentId = parent ? parent.id : "NONE";
        const parentHash = parent ? parent.hash : "00000000";

        const hashInput = [
          parentHash,
          nextMode,
          payloadFrame,
          stableString(payloadParams),
          stableString(payloadMetrics)
        ].join("|");

        const commit = {
          id,
          parent: parentId,
          mode: nextMode,
          frame: payloadFrame,
          params: payloadParams,
          metrics: payloadMetrics,
          hash: toyHash(hashInput)
        };

        commits.push(commit);
        nextCommit += 1;
        return commit;
      }

      function verifyChain() {
        let expectedParentHash = "00000000";
        for (let i = 0; i < commits.length; i++) {
          const c = commits[i];
          const parentId = i === 0 ? "NONE" : commits[i - 1].id;
          if (c.parent !== parentId) return false;

          const hashInput = [
            expectedParentHash,
            c.mode,
            c.frame,
            stableString(c.params),
            stableString(c.metrics)
          ].join("|");

          if (toyHash(hashInput) !== c.hash) return false;
          expectedParentHash = c.hash;
        }
        return true;
      }

      function updateHUD() {
        const last = commits[commits.length - 1];
        const chainOk = verifyChain();

        modeChip.textContent = "Mode: " + mode;
        frameChip.textContent = "Frame: X / Y (active " + frame + ")";
        spreadChip.textContent = "Spread: " + cachedMetrics.spread.toFixed(4);
        errorChip.textContent = "Constraint error: " + cachedMetrics.constraintError.toFixed(4);
        hashChip.textContent = "Last commit hash: " + (last ? last.hash : "00000000");

        chainChip.textContent = "Chain: " + (chainOk ? "OK" : "BROKEN");
        chainChip.className = "chip " + (chainOk ? "ok" : "warn");
      }

      function updateLog() {
        const last = commits[commits.length - 1];
        lastCommitEl.textContent = last ? JSON.stringify(last, null, 2) : "{}";

        lineageLogEl.innerHTML = "";
        for (let i = commits.length - 1; i >= 0; i--) {
          const c = commits[i];
          const li = document.createElement("li");
          li.textContent =
            c.id +
            " <- " +
            c.parent +
            " | " +
            c.mode +
            " | frame " +
            c.frame +
            " | spread " +
            c.metrics.spread.toFixed(4) +
            " | err " +
            c.metrics.constraintError.toFixed(4) +
            " | hash " +
            c.hash;
          lineageLogEl.appendChild(li);
        }
      }

      function commitAndRefresh(nextMode, payloadFrame, payloadParams) {
        cachedMetrics = measure();
        addCommit(nextMode, payloadFrame, payloadParams, cachedMetrics);
        updateHUD();
        updateLog();
      }

      function runRelax() {
        mode = "RELAX";
        for (let i = 0; i < 28; i++) integrateRelax();
        commitAndRefresh("RELAX", frame, {
          relaxNoise: params.relaxNoise,
          relaxDrift: params.relaxDrift
        });
      }

      function runConstrain() {
        mode = "CONSTRAIN";
        for (let i = 0; i < 26; i++) integrateConstrain(params.constrainStrength);
        commitAndRefresh("CONSTRAIN", frame, {
          constrainStrength: params.constrainStrength
        });
      }

      function runSwitchFrame() {
        const from = frame;
        frame = frame === "X" ? "Y" : "X";
        mode = "FRAME_SHIFT";
        for (let i = 0; i < 18; i++) integrateConstrain(0.08);
        commitAndRefresh("FRAME_SHIFT", frame, {
          fromFrame: from,
          toFrame: frame,
          constrainStrength: 0.08
        });
      }

      function resetDemo() {
        mode = "IDLE";
        frame = "X";
        commits.length = 0;
        nextCommit = 0;

        resetPoints();
        cachedMetrics = measure();

        addCommit("GENESIS", frame, { seed: "demo-v0.1.0" }, cachedMetrics);
        updateHUD();
        updateLog();
      }

      function toScreen(x, y) {
        const s = Math.min(viewW, viewH) * 0.42;
        return { x: viewW * 0.5 + x * s, y: viewH * 0.5 + y * s };
      }

      function drawGrid() {
        ctx.save();
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.25;

        for (let i = 1; i < 12; i++) {
          const t = i / 12;
          const x = t * viewW;
          const y = t * viewH;
          ctx.strokeStyle = "rgba(140, 173, 232, 0.18)";
          ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, viewH); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(viewW, y); ctx.stroke();
        }

        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = "rgba(205, 223, 255, 0.35)";
        ctx.beginPath(); ctx.moveTo(viewW * 0.5, 0); ctx.lineTo(viewW * 0.5, viewH); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, viewH * 0.5); ctx.lineTo(viewW, viewH * 0.5); ctx.stroke();
        ctx.restore();
      }

      function drawManifold() {
        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = frame === "X"
          ? "rgba(107, 191, 255, 0.95)"
          : "rgba(255, 200, 119, 0.95)";

        const steps = 280;
        ctx.beginPath();
        for (let i = 0; i <= steps; i++) {
          const t = (i / steps) * Math.PI * 2;
          const q = target(t);
          const s = toScreen(q.x, q.y);
          if (i === 0) ctx.moveTo(s.x, s.y);
          else ctx.lineTo(s.x, s.y);
        }
        ctx.stroke();

        ctx.fillStyle = "rgba(230, 240, 255, 0.9)";
        ctx.font = `13px ${monoFont}`;
        const label = frame === "X" ? "Frame X manifold: circle" : "Frame Y manifold: infinity curve";
        ctx.fillText(label, 14, 24);

        ctx.restore();
      }

      function drawPoints() {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        for (const p of points) {
          const s = toScreen(p.x, p.y);
          const speed = Math.hypot(p.vx, p.vy);
          const alpha = clamp(0.11 + speed * 2.2, 0.14, 0.58);
          const tint = frame === "X" ? "111, 186, 255" : "255, 189, 116";
          ctx.fillStyle = `rgba(${tint}, ${alpha.toFixed(3)})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, 2.1, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawCaption() {
        const last = commits[commits.length - 1];
        const hash = last ? last.hash : "00000000";
        const text = "Control loop: RELAX -> CONSTRAIN -> FRAME_SHIFT | last hash " + hash;
        ctx.save();
        ctx.fillStyle = "rgba(214, 227, 255, 0.85)";
        ctx.font = `12px ${monoFont}`;
        ctx.fillText(text, 14, viewH - 14);
        ctx.restore();
      }

      function render() {
        ctx.clearRect(0, 0, viewW, viewH);
        drawGrid();
        drawManifold();
        drawPoints();
        drawCaption();
      }

      function tick() {
        coast();
        render();
        requestAnimationFrame(tick);
      }

      document.getElementById("relaxBtn").addEventListener("click", runRelax);
      document.getElementById("constrainBtn").addEventListener("click", runConstrain);
      document.getElementById("switchBtn").addEventListener("click", runSwitchFrame);
      document.getElementById("resetBtn").addEventListener("click", resetDemo);

      window.addEventListener("keydown", (event) => {
        const key = event.key.toLowerCase();
        if (key === "r") runRelax();
        if (key === "c") runConstrain();
        if (key === "x") runSwitchFrame();
        if (key === " ") mode = "IDLE";
        if (key === "enter") resetDemo();
      });

      resize();
      resetDemo();
      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>